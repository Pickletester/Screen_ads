<script>
  const A = document.getElementById("layerA");
  const B = document.getElementById("layerB");
  const debug = document.getElementById("debug");

  let front = A, back = B;

  function swapLayers(){
    const tmp = front; front = back; back = tmp;
  }

  function showError(msg){
    console.log(msg);
    debug.style.display = "block";
    debug.textContent = msg;
  }
  function clearError(){ debug.style.display="none"; debug.textContent=""; }

  // ====== YOUR PLAYLIST (or fetched playlist.json) ======
  let playlist = [
    { type:"image", url:"Applebox.jpg", duration:10 },
    { type:"image", url:"Comcast.jpg", duration:10 },
    { type:"image", url:"Feet_DR.jpg", duration:10 },
    { type:"image", url:"Howard_Hannah.jpg", duration:10 },
    { type:"image", url:"Itaily.jpg", duration:10 },
    { type:"image", url:"J_Frances2.jpg", duration:10 },
    { type:"image", url:"Lorenzi.jpg", duration:10 },
    { type:"image", url:"Mission.jpg", duration:10 },
    { type:"image", url:"Pickleball_lifeline.jpg", duration:10 },
    { type:"image", url:"Sun_Chevy.jpg", duration:10 },
    { type:"image", url:"ad1.jpg", duration:10 },
    { type:"video", url:"Screen_2_1.mp4", duration:15 }
  ];

  // ====== SYNC ======
  const params = new URLSearchParams(location.search);
  const OFFSET = parseInt(params.get("offset") || "0", 10) || 0;

  function nowSec(){ return Math.floor(Date.now()/1000) + OFFSET; }
  function loopLen(){ return playlist.reduce((s,i)=>s+i.duration,0); }

  function getSynced(){
    const L = loopLen();
    const t = ((nowSec() % L) + L) % L;
    let acc = 0;
    for (let i=0;i<playlist.length;i++){
      const d = playlist[i].duration;
      if (t < acc + d){
        return { index:i, elapsed:t-acc, remaining:(acc+d)-t };
      }
      acc += d;
    }
    return { index:0, elapsed:0, remaining:playlist[0].duration };
  }

  // ====== CROSSFADE PLAYER ======
  let timer = null;
  let safety = null;

  function clearTimers(){
    if (timer) clearTimeout(timer);
    if (safety) clearTimeout(safety);
    timer = safety = null;
  }

  function buildMedia(item){
    back.innerHTML = ""; // only clear BACK layer (front stays visible)
    clearError();

    if (item.type === "image"){
      const img = document.createElement("img");
      img.src = item.url;

      return new Promise((resolve, reject) => {
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error("Image failed: " + item.url));
      });
    }

    if (item.type === "video"){
      const vid = document.createElement("video");
      vid.src = item.url;
      vid.muted = true;
      vid.playsInline = true;
      vid.autoplay = false; // we will call play()
      vid.preload = "auto";

      return new Promise((resolve, reject) => {
        vid.addEventListener("loadedmetadata", () => resolve(vid), { once:true });
        vid.addEventListener("error", () => reject(new Error("Video failed: " + item.url)), { once:true });
      });
    }

    return Promise.reject(new Error("Unknown type"));
  }

  function crossfadeToBack(){
    // show back, then hide old front after transition
    back.classList.add("show");
    front.classList.remove("show");
    swapLayers();
  }

  async function playFrom(index, elapsed, remaining){
    clearTimers();

    const item = playlist[index];

    try {
      const media = await buildMedia(item);
      back.appendChild(media);

      // Seek into video if needed
      if (item.type === "video"){
        const startAt = Math.max(0, Math.min(item.duration - 0.1, elapsed));
        try { media.currentTime = startAt; } catch(e){}

        // Start playback right before fade (so it’s “hot”)
        const p = media.play();
        if (p && p.catch) p.catch(()=>{ /* TB1 may block; muted helps */ });
      }

      // Fade with content ready (no black flash)
      crossfadeToBack();

      // Advance timing
      const nextIndex = (index + 1) % playlist.length;

      // Use our own timer (more reliable than onended on TB1)
      timer = setTimeout(() => {
        playFrom(nextIndex, 0, playlist[nextIndex].duration);
      }, Math.max(250, remaining * 1000));

      // Safety for video end (optional)
      if (item.type === "video"){
        safety = setTimeout(() => {
          playFrom(nextIndex, 0, playlist[nextIndex].duration);
        }, Math.max(250, remaining * 1000 + 500));
      }

    } catch (e){
      showError(e.message);
      // Skip quickly
      const nextIndex = (index + 1) % playlist.length;
      timer = setTimeout(() => playFrom(nextIndex, 0, playlist[nextIndex].duration), 1500);
    }
  }

  function start(){
    const s = getSynced();
    playFrom(s.index, s.elapsed, s.remaining);
  }

  start();
</script>
